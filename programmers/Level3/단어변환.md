## 단어 변환

<hr/>

### :heavy_check_mark: 내가 푼 답안

```javascript
function solution(begin, target, words) {
  let answer = 0;
  let countArr = [];
  let visi = [];

  if (words.indexOf(target) === -1) {
    return 0;
  }

  visi.push(begin);
  dfs(begin, 0, visi);

  function dfs(begin, count, visited) {
    if (begin == target) {
      countArr.push(count);
      return;
    }

    for (let i = 0; i < begin.length; i++) {
      words.map((e) => {
        if (visited.indexOf(e) == -1 && begin[i] != e[i] && e == begin.replace(begin[i], e[i])) {
          visited.push(begin);
          dfs(e, count + 1, visited);
          visited.pop();
        }
      });
    }
  }
  return countArr.length ? Math.min(...countArr) : 0;
}
```

begin글자의 index를 돌아가면서 한글자씩 word랑 비교해서 dfs해줬다.  
만약 begin의 index의 글자와 word의 index의 글자가 같거나 word가 방문했던경우는 제외해줬다.  
`visited.pop();` 같은 index의 있는 글자가 또 있는 경우를 생각해서 방문했던 word를 pop해줬다.  
근데...

힘들게 풀었는데.. 제출 테스트3이 실패다 ㅠㅠ 이유를 모르겠다..나중에 다시 시도해야겠다..

<hr/>

### :heavy_check_mark: 참고하면 좋은 다른 답안

Thanks for https://programmers.co.kr/learn/courses/30/lessons/43163/solution_groups?language=javascript&page=1

```javascript
function solution(begin, target, words) {
  let answer = 51,
    result = 0,
    visited = Array(words.length).fill(false);

  const check = (str1, str2) => {
    let count = 0;
    for (let i = 0; i < str1.length; i++) {
      if (str1[i] !== str2[i]) ++count;
    }
    return count === 1 ? true : false;
  };

  const dfs = (str, count) => {
    if (str === target) {
      answer = answer > count ? count : answer;
      return;
    } else if (count === words.length) {
      answer = 51;
      return;
    } else {
      words.forEach((v, i) => {
        if (check(str, v) && !visited[i]) {
          visited[i] = true;
          dfs(v, count + 1);
          visited[i] = false;
        }
      });
    }
  };

  dfs(begin, 0);

  return answer === 51 ? 0 : answer;
}
```

비슷하게 푼 다른 답안이다..
check함수로 다른부분을 체크해줬다.
