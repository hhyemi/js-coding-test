## 네트워크

<hr/>

### :heavy_check_mark: 내가 푼 답안

```javascript
function solution(n, computers) {
  let count = 0;
  let visited = new Array(n);

  visited.fill(0);

  for (let i = 0; i < n; i++) {
    if (visited[i] == 0) {
      dfs(i);
      count++;
    }
  }

  function dfs(i) {
    for (let j = 0; j < n; j++) {
      if (computers[i][j] == 1 && visited[j] == 0) {
        visited[j] = 1;
        dfs(j);
      }
    }
  }
  return count;
}
```

DFS문제이다.
컴퓨터의 개수만큼 배열을 생성하고 0으로 채운다. (방문했음: 1 , 방문안했음: 0)  
그러고 컴퓨터의 개수만큼 검사를 해준다. (방문했던 곳은 검사 x)  
dfs함수에서도 재귀적으로 타고들어가서 끝까지 검사해준다.

<hr/>

### :heavy_check_mark: 참고하면 좋은 다른 답안

Thanks for https://programmers.co.kr/learn/courses/30/lessons/43162/solution_groups?language=javascript

```javascript
let arr;
let visitArr;

function solution(n, computers) {
  let ctr = 0;
  arr = computers;
  visitArr = new Array(n).fill(false);

  for (let i in arr) {
    ctr += dfs(i);
  }

  return ctr;
}

function dfs(i) {
  if (visitArr[i] == true) return 0;
  else visitArr[i] = true;

  for (let j in arr[i]) {
    if (arr[i][j] == 1) dfs(j);
  }

  return 1;
}
```

- for in을 사용해서 깔끔하다.
- 0,1 대신 boolean사용

<br/>
