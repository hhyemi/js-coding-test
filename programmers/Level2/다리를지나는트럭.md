## 다리를 지나는 트럭

<hr/>

### :heavy_check_mark: 내가 푼 답안

```javascript
function solution(bridge_length, weight, truck_weights) {
  let answer = 0;

  let bridge = new Array(bridge_length);
  for (let i = 0; i < bridge.length; i++) {
    bridge[i] = 0;
  }

  let enterArr = [...truck_weights];

  while (truck_weights.length > 0) {
    if (bridge.reduce((acc, curr) => acc + parseInt(curr), -bridge[bridge.length - 1]) + enterArr[0] > weight) {
      bridge.unshift(0);
    } else {
      bridge.unshift(enterArr[0]);
      enterArr.splice(0, 1);
    }

    const remove = bridge.splice(bridge.length - 1, 1);
    if (remove != 0) {
      truck_weights.splice(0, 1);
    }
    answer++;
  }

  return answer;
}
```

`let bridge = new Array(bridge_length);` 다리의 길이만큼 배열을 생성한 후 모든 값을 0으로 초기화했다.  
여기서  
` let enterArr = [...truck_weights];`을 안하고 `truck_weights`을 사용했더니... weight 넘는지 계산할때 자꾸 들어가서 answer이 증가하였다.... 후.. 배열 복사를 한 후 다리를 지나는 배열은 제거 시켜줘야 한다.  
또 weight 계산할때 초기값을 마지막 다리를 건너는 트럭값을 빼주기 위해 (나가면서 들어오기 가능,,) `-bridge[bridge.length - 1]`를 해준다.

트럭의 무게가 weight를 넘지 않으면 bridge에 추가시켜주고 enterArr에서 다리를 지나니까 지워준다.  
만약 넘으면 `0`값을 넣어준다.

그리고 bridge에 마지막 값을 잘라준다. 그 값이 truck_weights에 있으면 splice해준다.

#### 개선하면 좋은 부분

- `bridge.reduce((acc, curr) => acc + parseInt(curr), -bridge[bridge.length - 1])`이 부분 대신 bridge에 unshift해줄때 count를 변수에 구해놓기

<br/>
