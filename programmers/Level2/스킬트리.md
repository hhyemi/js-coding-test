## 스킬트리

<hr/>

### :heavy_check_mark: 내가 푼 답안

```javascript
function solution(skill, skill_trees) {
  let skillArr = [...skill];

  let resultArr = skill_trees.map((e) => [...e].filter((el) => skillArr.indexOf(el) != -1).join(''));

  let count = resultArr.filter((e) => e == '').length;
  resultArr = resultArr.filter((e) => e != '');

  let arr = skillArr.map((e, i) => {
    resultArr = resultArr.filter((el) => e == el[i] || (e == el[i] && el[i + 1] == null) || el[i] == null);
    return resultArr;
  });

  return count + arr[arr.length - 1].length;
}
```

`let resultArr = skill_trees.map((e)...` : 처음에 skill에 해당하는 글자만 남긴다.  
`resultArr` 에서 공백부분의 카운트를 세고 (스킬트리상관없으니 통과) 공백부분을 배열에서 삭제한다.

그리고 조건을 줘서 스킬트리에 맞는지 확인한다.

1. 스킬트리의 index부분과 resultArr의 index부분이 맞는경우
2. 맞지만 resultArr 다음인덱스 값이 없는경우 (스킬트리는 맞고 끝난경우)
3. resultArr의 해당 인덱스 값이 없는경우 (스킬트리는 맞고 끝난경우)

그러고 count와 조건에 맞는 배열의 마지막 인덱스(조건에 살아남은 마지막것만 가져오기위해) 의 길이를 반환한다.

### 사용함수

-

<hr/>

### :heavy_check_mark: 참고하면 좋은 다른 답안

Thanks for https://programmers.co.kr/learn/courses/30/lessons/49993/solution_groups?language=javascript

```javascript
function solution(skill, skill_trees) {
  function isCorrect(n) {
    let test = skill.split('');
    for (var i = 0; i < n.length; i++) {
      if (!skill.includes(n[i])) continue;
      if (n[i] === test.shift()) continue;
      return false;
    }
    return true;
  }

  return skill_trees.filter(isCorrect).length;
}
```

filter를 를사용해서, 스킬트리의 각 문자열을 인풋으로 받아서 isCorrect함수에 넣는다.
그후에 각 문자열의 각 문자가 "스킬"에 존재하는가를 보고 존재안하면 바로 다음 문자 체크, 존재한다면! 그 문자가 "스킬의 첫문자"인가 본다. 맞으면 다음문자 체크. 만약 첫문자가 아니었으면, false를 던져주고, 이 과정 끝까지 포스가 없었으면 true를 던져준다.

<br/>
