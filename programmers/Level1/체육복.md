## 체육복

<hr/>

### :heavy_check_mark: 내가 푼 답안

```javascript
function solution(n, lost, reserve) {
    let answer = n-lost.length;
    
    for(let item of lost){
        const index = reserve.indexOf(item);
        const minIndex = reserve.indexOf(item-1);
        const maxIndex = reserve.indexOf(item+1);
        
        if(index != -1){
            reserve.splice(index,1);
            answer++;              
        }else if(minIndex != -1 ){
            reserve.splice(minIndex,1);
            answer++;
        }else if(maxIndex != -1){
            reserve.splice(maxIndex,1);
            answer++;            
        }
    }
    
    return answer;
}
```
하나의 문제가 오류나서 뭔지 고민을 많이 했다..  
결과는 같은 for문안에서 여분을 가진 사람이 잃어버렸을때 찾는것을 같이 하면 안됐다.  
왜냐면 여분을 가진 사람이 잃어버렸을때가 더 뒤쪽에 있는데 앞에서 그 사람꺼를 splice하면 못찾기 때문이다.  
<br/>
for문을 나눠서 해결하였다.


```javascript
function solution(n, lost, reserve) {
    let answer = n-lost.length;
    
    for(let i=0 ; i < lost.length ; i++){
        const index = reserve.indexOf(lost[i]);
         if(index != -1){
            reserve.splice(index,1);
            lost.splice(i,1);
             i--;
            answer++;              
        }
    }
    
    for(let item of lost){
        const minIndex = reserve.indexOf(item-1);
        const maxIndex = reserve.indexOf(item+1);
        
        if( minIndex != -1 ){
            reserve.splice(minIndex,1);
            answer++;
        }else if(minIndex === -1 && maxIndex != -1){
            reserve.splice(maxIndex,1);
            answer++;            
         }
    }
    
    return answer;
}
```
첫번째 for문이 돌때 잃어버린사람목록에도 지워줘야한다.  
안그러면 두번째 for문에도 검사하기 때문이다.  

<hr/>

### :heavy_check_mark: 참고하면 좋은 다른 답안 

Thanks for  https://programmers.co.kr/learn/courses/30/lessons/42862/solution_groups?language=javascript&type=all

```javascript
function solution(n, lost, reserve) {
    const realReserve = reserve.filter(r => !lost.includes(r));
    const realLost = lost.filter(r => !reserve.includes(r));

    const ableNum = realLost.filter(a => {
        return realReserve.find((b, i) => {
            const has = b === a-1 || b === a+1;
            if (has) {
                delete realReserve[i];
            }
            return has;
        });
    }).length;
    
    return n - (realLost.length - ableNum);
}
```
filter함수를 이용해서 여분을 가진 사람이 잃어버렸을때를 체크해준다.  
귀찮은 for문을 줄여준다.  
find 함수는 주어진 판별 함수를 만족하는 첫 번째 요소의 값을 반환한다.  
```b === a-1 || b === a+1``` 값이 있으면 delete해준다.  
```return has;```를 통해 true일때만 배열을 만들어준다.  
ableNum = 여분을 받은 사람  



<br/>

